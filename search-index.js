var searchIndex = {};
searchIndex["protocoll"] = {"doc":"some basic protocols and implementations for rust collections. inspired by\nclojure&#39;s design, albeit not persistent.","items":[[0,"map","protocoll","",null,null],[3,"VecSortedMap","protocoll::map","an array-map sorted by key. does not support `entry`; see\n[`Map::update`](#method.update). [`Map::update_in_place`](#method.update_in_place)\nis **not** much more efficient than `update` for this data structure.",null,null],[8,"Map","protocoll","basic protocol for maps.",null,null],[10,"fun","","a map maps from keys to values.",0,null],[10,"inc","","adds `v` at `k`.",0,null],[10,"dec","","removes key `k`.",0,null],[11,"plus","","pours another collection into this one.",0,null],[10,"zero","","`clear`.",0,null],[10,"shrink","","`shrink_to_fit`.",0,null],[10,"update","","like clojure&#39;s [update](http://clojuredocs.org/clojure.core/update).\n# example\n```\nuse protocoll::Map;\nuse std::collections::HashMap;\nlet m = [0,0,0,1,1,0,0,0].iter().fold\n    (HashMap::new(), |m,&amp;k| Map::update\n     (m, k, |n| 1 + n.unwrap_or(0)));\nassert_eq!(6, m[&amp;0]);\nassert_eq!(2, m[&amp;1]);\n```",0,null],[11,"merge","","like clojure&#39;s [merge-with](http://clojuredocs.org/clojure.core/merge-with).\n# example\n```\nuse protocoll::Map;\nuse std::collections::HashMap;\nuse std::ops::Add;\nlet m = [0,0,0,1,1,0,0,0].iter().fold\n    (HashMap::new(), |m,&amp;k| Map::update\n     (m, k, |n| 1 + n.unwrap_or(0)));\nlet m = Map::merge(m.clone(), m, usize::add);\nassert_eq!(12, m[&amp;0]);\nassert_eq!(4, m[&amp;1]);\n```",0,null],[10,"update_in_place","","like `Map::update` but can be more efficient.\n# example\n```\nuse protocoll::Map;\nuse std::collections::HashMap;\nlet a = [0,0,0,1,1,0,0,0];\nlet m1 = a.iter().fold\n    (HashMap::new(), |m,&amp;k| Map::update\n     (m, k, |n| 1 + n.unwrap_or(0)));\nlet m2 = a.iter().fold\n    (HashMap::new(), |m,&amp;k| Map::update_in_place\n     (m, k, 0, |n| *n += 1));\nassert_eq!(m1,m2);\n```",0,null],[10,"merge_in_place","","like `Map::merge` but more efficient.\n# example\n```\nuse protocoll::Map;\nuse std::collections::HashMap;\nuse std::ops::Add;\nlet a = [0,0,0,1,1,0,0,0];\nlet m = a.iter().fold\n    (HashMap::new(), |m,&amp;k| Map::update_in_place\n     (m, k, 0, |n| *n += 1));\nlet m = Map::merge_in_place(m.clone(), m, |u,v| *u += v);\nassert_eq!(12, m[&amp;0]);\nassert_eq!(4, m[&amp;1]);\n```",0,null],[8,"Set","","basic protocol for sets.",null,null],[10,"fun","","a set maps from items to themselves.",1,null],[10,"inc","","adds item `i`.",1,null],[10,"dec","","removes item `i`.",1,null],[11,"plus","","pours another collection into this one.",1,null],[10,"zero","","`clear`.",1,null],[10,"shrink","","`shrink_to_fit`.",1,null],[8,"Seq","","basic protocol for seqs.",null,null],[10,"fun","","a seq maps from indices to items. O(n) for `BinaryHeap`.",2,null],[10,"inc","","adds item `i`. both `Vec` and `VecDeque` grows to the right.",2,null],[10,"dec","","removes an item. for `Vec` it&#39;s the last one; for `VecDeque` the first;\nfor `BinaryHeap` it&#39;s the greatest one.",2,null],[11,"plus","","pours another collection into this one.",2,null],[10,"zero","","`clear`.",2,null],[10,"shrink","","`shrink_to_fit`.",2,null],[8,"Str","","basic protocol for strs;",null,null],[10,"inc","","appends char `c`.",3,null],[10,"dec","","pops the last char.",3,null],[10,"plus","","appends str `s`.",3,null],[10,"zero","","`clear`.",3,null],[10,"shrink","","`shrink_to_fit`.",3,null],[11,"plus","","pours another collection into this one.",0,null],[11,"merge","","like clojure&#39;s [merge-with](http://clojuredocs.org/clojure.core/merge-with).\n# example\n```\nuse protocoll::Map;\nuse std::collections::HashMap;\nuse std::ops::Add;\nlet m = [0,0,0,1,1,0,0,0].iter().fold\n    (HashMap::new(), |m,&amp;k| Map::update\n     (m, k, |n| 1 + n.unwrap_or(0)));\nlet m = Map::merge(m.clone(), m, usize::add);\nassert_eq!(12, m[&amp;0]);\nassert_eq!(4, m[&amp;1]);\n```",0,null],[11,"default","protocoll::map","",4,{"inputs":[],"output":{"name":"vecsortedmap"}}],[11,"clone","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"partial_cmp","","",4,null],[11,"lt","","",4,null],[11,"le","","",4,null],[11,"gt","","",4,null],[11,"ge","","",4,null],[11,"cmp","","",4,null],[11,"hash","","",4,null],[11,"new","","",4,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","",4,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","",4,null],[11,"reserve","","",4,null],[11,"shrink_to_fit","","",4,null],[11,"clear","","",4,null],[11,"contains_key","","O(log(len))",4,null],[11,"get","","O(log(len))",4,null],[11,"get_mut","","O(log(len))",4,null],[11,"insert","","O(log(len)) when `k` already exists. O(len) for inserting a new entry,\ncaused by shifting all entries after it, which can be avoided by always\ninserting in order.",4,null],[11,"remove","","O(log(len)) when `k` does not exist. O(len) for removing an entry,\nbecause of the need for shifting all entries after it.",4,null],[11,"append","","",4,null],[11,"view_content","","a view for the underlying vec. `&amp;self` methods for `Vec` such as `get`\nand `split` can be accessed through this.",4,null],[11,"iter","","iterate over the underlying vec. note: iterator element type is **not**\n`(&amp;K,&amp;V)` but rather `&amp;(K,V)`. `iter_mut` is not supported for this\ncollection. see [`update_all_in_place`](#method.update_all_in_place) for\nthe same functionality.",4,null],[11,"len","","",4,null],[11,"is_empty","","",4,null],[11,"update_all_in_place","","this makes up for the (intentional) absence of `iter_mut`.\n# example\n```    \n// a somewhat unecessary way to create a mapping from square numbers to\n// the fibonacci sequence.\nuse protocoll::map::VecSortedMap;\nlet m:VecSortedMap&lt;u32,u32&gt; =\n    (0..).map(|n| (n * n, 0))\n    .take(13).collect();\nlet (ref mut a, ref mut b) = (0,1);\nlet m = m.update_all_in_place\n    (|_,v| {*v = *a;\n            *a = *b;\n            *b += *v});\nassert_eq!(m[&amp;   0], 0);\nassert_eq!(m[&amp;   1], 1);\nassert_eq!(m[&amp;   4], 1);\nassert_eq!(m[&amp;   9], 2);\nassert_eq!(m[&amp;  16], 3);\nassert_eq!(m[&amp;  25], 5);\nassert_eq!(m[&amp;  36], 8);\nassert_eq!(m[&amp; 144], 144);\n```    ",4,null],[11,"into_iter","","",4,null],[11,"extend","","",4,null],[11,"extend","","",4,null],[11,"from_iter","","",4,{"inputs":[{"name":"i"}],"output":{"name":"vecsortedmap"}}],[11,"index","","",4,null],[11,"fmt","","",4,null],[11,"fun","","",4,null],[11,"inc","","",4,null],[11,"dec","","",4,null],[11,"zero","","",4,null],[11,"shrink","","",4,null],[11,"update","","",4,null],[11,"update_in_place","","",4,null],[11,"merge_in_place","","",4,null],[11,"plus","protocoll","pours another collection into this one.",1,null],[11,"plus","","pours another collection into this one.",2,null]],"paths":[[8,"Map"],[8,"Set"],[8,"Seq"],[8,"Str"],[3,"VecSortedMap"]]};
initSearch(searchIndex);
